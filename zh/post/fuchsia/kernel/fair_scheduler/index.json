[{"content":"Oops!\n","description":"","id":2,"section":"","tags":null,"title":"关于","uri":"http://chendm.gitee.io/blog/zh/about/"},{"content":"安装docker-compose docker-compose-Windows-x86_64.exe\n下载后放到系统path路径下，并重命名为dm.exe\n配置远程连接命令行环境 SET DOCKER_TLS_VERIFY=1\r# 远程docker的主机连接\rSET DOCKER_HOST=tcp://192.168.99.100:2376\r# 登录远程docker使用到的证书所在目录\rSET DOCKER_CERT_PATH=E:\\vms\\machines\\vm\rSET COMPOSE_CONVERT_WINDOWS_PATHS=true\r如果安装了docker-machine，则可以通过运行如下命令设置命令行环境:\n@FOR /f \u0026quot;tokens=*\u0026quot; %i IN ('dm env vm') DO @%i\r部署docker-compose.yml 新建docker-compose.yml:\nversion: '2'\rservices:\rzookeeper:\rimage: wurstmeister/zookeeper\rports:\r- \u0026quot;2181:2181\u0026quot;\rkafka:\rimage: wurstmeister/kafka\rports:\r- \u0026quot;9092\u0026quot;\renvironment:\rKAFKA_ADVERTISED_HOST_NAME: 192.168.99.100\rKAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\rvolumes:\r- /var/run/docker.sock:/var/run/docker.sock\r部署docker-compose.yml:\ndc -f docker-compose.yml up\r","description":"","id":3,"section":"post","tags":["Docker","Docker Compose"],"title":"使用docker-compose部署服务到远程Docker","uri":"http://chendm.gitee.io/blog/zh/post/docker/compose/deploy-to-remote-docker/"},{"content":"从 JVM 虚拟机的角度来看，只存在两种不同的类加载器：\n 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分； 所有其他的类加载器，独立于虚拟机外部，都继承自抽象类 java.lang.ClassLoader。  而绝大多数Java应用都会用到如下 3 中系统提供的类加载器：\n 启动类加载器（Bootstrap/Primordial/NULL ClassLoader）：顶层的类加载器，没有父类加载器。\n负责加载 /lib 目录下的，或则被 -Xbootclasspath 参数所指定路径中的，并被 JVM 识别的\n（仅按文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录也不会被加载）类库加载到虚拟机内存中。\n所有被 Bootstrap classloader 加载的类，它的 Class.getClassLoader 方法返回的都是 null，所以也称作 NULL ClassLoader。 扩展类加载器（Extension CLassLoader）：由 sun.misc.Launcher$ExtClassLoader 实现，负责加载 \u0026lt;JAVA_HOME\u0026gt;/lib/ext 目录下，\n或被 java.ext.dirs 系统变量所指定的目录下的所有类库； 应用程序类加载器（Application/System ClassLoader）：由 sun.misc.Launcher$AppClassLoader 实现。\n它是 ClassLoader.getSystemClassLoader() 方法的默认返回值，所以也称为系统类加载器（System ClassLoader）。\n它负责加载 classpath 下所指定的类库，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  源码：\npublic class Name {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;Name.class location: src/main/java/first\u0026quot;);\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;/\u0026quot;));\rSystem.out.println(\u0026quot;***********************************************\u0026quot;);\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;first.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;first/first.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;first/first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/first.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;/first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/first/first.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;/first/first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;second/second.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;second/second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/second/second.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;/second/second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/first/second/second.txt\\\u0026quot;):\u0026quot;+Name.class.getResource(\u0026quot;/first/second/second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;root.txt\\\u0026quot;:)\u0026quot;+Name.class.getResource(\u0026quot;root.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getResource(\\\u0026quot;/root.txt\\\u0026quot;:)\u0026quot;+Name.class.getResource(\u0026quot;/root.txt\u0026quot;));\rSystem.out.println(\u0026quot;***********************************************\u0026quot;);\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;/\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;/\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;first.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;first/first.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;first/first.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;second.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;second/second.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;second/second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;first/second/second.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;first/second/second.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;root.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;root.txt\u0026quot;));\rSystem.out.println(\u0026quot;class.getClassLoader().getResource(\\\u0026quot;/root.txt\\\u0026quot;):\u0026quot;+Name.class.getClassLoader().getResource(\u0026quot;/root.txt\u0026quot;));\r}\r}\r运行结果：\nName.class location: src/main/java/first\rclass.getResource(\u0026quot;\u0026quot;):file:/E:/Java/validation/build/classes/java/main/first/\rclass.getResource(\u0026quot;/\u0026quot;):file:/E:/Java/validation/build/classes/java/main/\r***********************************************\rclass.getResource(\u0026quot;first.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/first.txt\rclass.getResource(\u0026quot;first/first.txt\u0026quot;):null\rclass.getResource(\u0026quot;/first.txt\u0026quot;):null\rclass.getResource(\u0026quot;/first/first.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/first.txt\rclass.getResource(\u0026quot;second/second.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/second/second.txt\rclass.getResource(\u0026quot;/second/second.txt\u0026quot;):null\rclass.getResource(\u0026quot;/first/second/second.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/second/second.txt\rclass.getResource(\u0026quot;root.txt\u0026quot;:)null\rclass.getResource(\u0026quot;/root.txt\u0026quot;:)file:/E:/Java/validation/build/resources/main/root.txt\r***********************************************\rclass.getClassLoader().getResource(\u0026quot;\u0026quot;):file:/E:/Java/validation/build/classes/java/main/\rclass.getClassLoader().getResource(\u0026quot;/\u0026quot;):null\rclass.getClassLoader().getResource(\u0026quot;first.txt\u0026quot;):null\rclass.getClassLoader().getResource(\u0026quot;first/first.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/first.txt\rclass.getClassLoader().getResource(\u0026quot;second.txt\u0026quot;):null\rclass.getClassLoader().getResource(\u0026quot;second/second.txt\u0026quot;):null\rclass.getClassLoader().getResource(\u0026quot;first/second/second.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/first/second/second.txt\rclass.getClassLoader().getResource(\u0026quot;root.txt\u0026quot;):file:/E:/Java/validation/build/resources/main/root.txt\rclass.getClassLoader().getResource(\u0026quot;/root.txt\u0026quot;):null\r","description":"","id":4,"section":"post","tags":["Java","Java ClassLoader"],"title":"Class和ClassLoader的getResource()方法的差别","uri":"http://chendm.gitee.io/blog/zh/post/java/getresource/"},{"content":"按语言分离源码文件夹 Gradle的语言插件使用惯例来发现及编译源码。例如java插件会自动编译位于\nsrc/main/java目录下的代码。其它语言也是同样的模式。目录路径的最后一部\n分通常表示所期望源码的格式。\n某些编译器可以在同一个源码目录交叉编译多种语言。Groovy编译器可以处理位于\nsrc/main/groovy目录下混合了Java和Groovy的源码文件。Gradle推荐把源码\n按语言分类存储到不同的目录中，因为构建更具有性能，用户和构建都可以做出更强的假设。\n.\r├── build.gradle\r├── settings.gradle\r└── src\r└── main\r├── java\r│ └── HelloWorld.java\r└── kotlin\r└── Utils.kt\r按测试类型分离源码 项目定义和运行不同类型的测试是很常见的，例如单元测试、集成测试、功能测试或冒烟测试。\n最理想的情况是，每个测试类型的测试源代码应该存储在专用的源目录中。分离的测试源代码对\n可维护性和关注点分离有积极的影响，因为您可以运行相互独立的测试类型。\n.\r├── build.gradle\r├── gradle\r│ └── integration-test.gradle\r├── settings.gradle\r└── src\r├── integTest\r│ └── java\r│ └── DefaultFileReaderIntegrationTest.java\r├── main\r│ └── java\r│ ├── DefaultFileReader.java\r│ ├── FileReader.java\r│ └── StringUtils.java\r└── test\r└── java\r└── StringUtilsTest.java\rGradle在源代码集概念的帮助下建立了源代码目录模型。通过将一个源集的实例指向一个或多个源代码目录，\nGradle将自动创建相应的即时编译任务:\nsourceSets {\rintegTest {\rjava.srcDir file('src/integTest/java')\rresources.srcDir file('src/integTest/resources')\rcompileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath\rruntimeClasspath += output + compileClasspath\r}\r}\r源集只负责编译源代码，但不负责执行字节码。为了执行测试，需要建立相应的Test类型任务:\ntask integTest(type: Test) {\rdescription = 'Runs the integration tests.'\rgroup = 'verification'\rtestClassesDirs = sourceSets.integTest.output.classesDirs\rclasspath = sourceSets.integTest.runtimeClasspath\rmustRunAfter test\r}\rcheck.dependsOn integTest\r尽可能使用标准约定 所有Gradle核心插件都遵循软件工程范例约定。插件为用户提供了在特定上下文中合理的默认值和标准、约定。\n从java插件为例：\n 它将目录src/main/java定义为编译的默认源目录。 编译后的源代码和其他工件(如JAR文件)的输出目录是build。  通过遵守默认约定，项目的新开发人员立即知道如何找到解决问题的方法。虽然可以重新配置这些约定，\n但这会使构建脚本用户和作者更难管理构建逻辑及其结果。尽量遵守默认约定，除非您需要适应遗留项目的布局。\n总是定义一个settings文件 Gradle每次构建调用都会试图定位settings.gradle (Groovy DSL)或settings.gradle.kts (Kotlin DSL)文件。\n为此，运行时将遍历目录树的层次结构，直到根目录。一旦找到设置文件，算法就停止搜索。\n始终将settings.gradle添加到构建的根目录中，以避免对最初的性能产生影响。\n本建议适用于单个项目构建和多个项目构建。该文件可以为空，也可以定义所需的项目名称。\n一个带有设置文件的典型Gradle项目看起来就是这样的:\n.\r├── build.gradle\r└── settings.gradle\r使用buildSrc抽象命令式逻辑 把复杂的构建逻辑封装为定制任务或二进制插件不失为一种好的选择。自定义任务和插件实现不应该存在于构建脚本中。\n只要代码不需要在多个独立项目之间共享，使用buildSrc就非常方便。\n目录buildSrc被视为一个被包含的构建。一旦发现该目录，Gradle就会自动编译并测试这些代码，并将其放入构建脚本的类路径中。\n对于多项目构建，只能有一个buildSrc目录，该目录必须位于根项目目录中。与脚本插件相比，buildSrc应该是首选，因为它更易于维护、重构和测试代码。\nbuildSrc使用适用于Java和Groovy项目的相同源代码约定。它还提供了对Gradle API的直接访问。\n可以在buildSrc目录下专用的build.gradle声明其他依赖项:\nbuildSrc/build.gradle\rrepositories {\rmavenCentral()\r}\rdependencies {\rtestImplementation 'junit:junit:4.12'\r}\r包含buildSrc的典型项目具有以下布局:\n.\r├── build.gradle\r├── buildSrc\r│ ├── build.gradle\r│ └── src\r│ ├── main\r│ │ └── java\r│ │ └── com\r│ │ └── enterprise\r│ │ ├── Deploy.java\r│ │ └── DeploymentPlugin.java\r│ └── test\r│ └── java\r│ └── com\r│ └── enterprise\r│ └── DeploymentPluginTest.java\r└── settings.gradle\rbuildSrc下的任何代码都应该使用类似于应用程序代码的包。如果需要额外的配置(例如，应用插件或声明依赖项)，buildSrc目录可以放置一个构建脚本。\nbuildSrc中的更改会导致整个项目变得过时。因此，在进行小的增量更改时，——no-rebuild命令行选项通常有助于获得更快的反馈。\n请记住定期运行完整的构建，或者至少在完成时运行。\n在gradle.properties中声明属性 在Gradle中，属性可以在构建脚本、gradle.properties中定义，或作为命令行上的参数传进来。\n在特定场景的命令行中声明属性是很常见的。例如，仅针对构建的这一次调用，您可能希望传入一个特定的属性值来控制运行时行为。\n构建脚本中的属性很容易成为维护的难题，并影响构建脚本逻辑。gradle.properties有助于将属性从构建脚本中分离出来，\n应该将其作为可行的选项加以研究。它是放置控制构建环境的属性的好地方。\n一个典型的项目把gradle.properties放置于构建的根目录中。或者，如果您希望将该文件应用于您机器上的所有构建，\n那么该文件也可以位于GRADLE_USER_HOME目录中。\n.\r├── build.gradle\r├── gradle.properties\r└── settings.gradle\r避免任务输出重叠 任务应该定义输入和输出，以获得增量构建功能的性能好处。在声明任务的输出时，请确保用于写入输出的目录在项目中的所有任务中是唯一的。\n混合或覆盖由不同任务产生的输出文件会损害最新的检查，从而导致更慢的构建。\n反过来，这些文件系统的更改可能会阻止Gradle构建缓存正确地标识和缓存本来可以缓存的任务。\n使用定制的Gradle发布版进行标准化构建 企业通常希望通过定义公共约定或规则来标准化组织中所有项目的构建平台。您可以在初始化脚本的帮助下实现这一点。\n初始化脚本使得在一台机器上跨所有项目应用构建逻辑变得非常容易。例如，声明内部存储库及其凭证。\n这种方法有一些缺点。首先，您必须在公司的所有开发人员之间沟通安装过程。此外，统一更新初始化脚本逻辑也很有挑战性。\n定制的Gradle发布版本是这个问题的实际解决方案。一个自定义的Gradle发布版本由标准的Gradle分布加上一个或多个自定义初始化脚本组成。\n初始化脚本与发行版绑定在一起，并在每次运行构建时应用。开发人员只需要将他们签入的Wrapper文件指向自定义Gradle发行版的URL。\n自定义的发布版本的根目录也可以包含一个gradle.properties文件，它提供组织范围内的一组控制构建环境的属性。\n以下步骤通常用于创建自定义发布版本：\n 实现下载和重新包装一个Gradle分发版的逻辑； 使用所需的逻辑定义一个或多个初始化脚本； 将初始化脚本与Gradle分发包捆绑在一起，形成归档文件； 将Gradle分发归档文件上传到HTTP服务器； 更改所有项目的Wrapper文件，指向自定义Gradle发布版的URL。  plugins {\rid 'base'\r}\r// This is defined in buildSrc\rimport org.gradle.distribution.DownloadGradle\rversion = '0.1'\rtask downloadGradle(type: DownloadGradle) {\rdescription = 'Downloads the Gradle distribution with a given version.'\rgradleVersion = '4.6'\r}\rtask createCustomGradleDistribution(type: Zip) {\rdescription = 'Builds custom Gradle distribution and bundles initialization scripts.'\rdependsOn downloadGradle\rdef projectVersion = project.version\rarchiveFileName = downloadGradle.gradleVersion.map { gradleVersion -\u0026gt;\r\u0026quot;mycompany-gradle-${gradleVersion}-${projectVersion}-bin.zip\u0026quot;\r}\rfrom zipTree(downloadGradle.destinationFile)\rfrom('src/init.d') {\rinto \u0026quot;${downloadGradle.distributionNameBase.get()}/init.d\u0026quot;\r}\r}\r","description":"","id":5,"section":"post","tags":["Gradle","Gradle Organizing"],"title":"Organizing Gradle Project","uri":"http://chendm.gitee.io/blog/zh/post/gradle/organizing-gradle-project/"},{"content":"Gradle的核心是基于依赖的编程语言。从gradle的角度看，用户可以定义任务及任务间的依赖。Gradle保证这些任务\n按照依赖顺序执行，且每个任务只执行一次。这些任务形成了一个有向元环图(DAG)。在执行任务时，工具可以构建这种图。\nGradle会在任务执行前完全构建好依赖DAG图。这是Gradle如此强大的核心所在。\n而构建脚本则用来配置这个DAG依赖图。\n构建阶段 Gradle有三个不一样的构建阶段：\n Initialization  Gradle支持单项目和多项目构建。在初始化阶段，Gradle会确定哪些项目将参与到构建中，并为每个参与的\n项目创建一个Project实例。\n Configuration  Project实例在些阶段被配置。参与构建的所有项目的构建脚本都会被执行。\n Execution  在此阶段，Gradle会从配置阶段中生成并配置好的任务中挑出一个任务子集来执行。\n这个任务子集由传入到gradle命令的任务名及当前所处目录确定。Gradle会按顺序\n依次执行这些任务。\nSettings文件 此文件在初始化阶段执行。多项目构建在项目根目录必须要有settings.gradle文件，\n它用于确定哪些项目参与到多项目构建。对于单项，这个文件是可选的。除了定义需要\n包含的项目外，还可以向构建脚本的类路径添加类库。\n在构建脚本对属性访问和方法调用都将委托给项目对象。类似地，settings文件中的属性访问和方法调用被委托给设置对象。\n多项目构建 多项目构建是在Gradle的一次执行中构建多个项目的构建。您必须在设置文件中声明参与到多项目构建的项目。\n项目位置 多项目构建总是由具有单个根的树表示。树中的每个元素表示一个项目。项目有一个路径，该路径表示项目在多项目构建树中的位置。\n在大多数情况下，项目路径与项目在文件系统中的物理位置是一致的。但是，这种行为是可配置的。项目树是在settings.gradle文件中创建的。\n默认情况下，假设settings文件的位置也是根项目的位置。\nBuilding the tree 在设置文件中，您可以使用一组方法来构建项目树。分层和平面物理布局得到了特殊的支持。\nHierarchical layouts settings.gradle\ninclude 'project1', 'project2:child', 'project3:child1'\rinclude方法以项目路径作为参数。假定项目路径等于相对的物理文件系统路径。\n例如，默认情况下，路径“services:api”映射到文件夹“services/api”（相对于项目根目录）。\n您只需要指定树的叶子,这意味着包含路径“services:hotels:api”将创建3个项目:\n services services:hotels services:hotels:api  Flat layouts settings.gradle\nincludeFlat 'project3', 'project4'\rincludeFlat方法以目录名作为参数。这些目录需要作为根项目目录的兄弟目录存在。\n这些目录的位置被认为是多项目树中根项目的子项目。\n修改项目树的元素 在设置文件中创建的多项目树由所谓的项目描述符组成。\n您可以随时在设置文件中修改这些描述符。要访问描述符，可以这样做:\nsettings.gradle\nprintln rootProject.name\rprintln project(':projectA').name\r使用此描述符，您可以更改项目的名称、项目目录和构建文件:\nsettings.gradle\nrootProject.name = 'main'\rproject(':projectA').projectDir = new File(settingsDir, '../my-project-a')\rproject(':projectA').buildFileName = 'projectA.gradle'\rInitialization Gradle如何知道是做单个项目还是多项目构建?如果您使用设置文件从目录触发多项目构建，那么事情就很简单了。\n但是Gradle还允许您在参与构建的任何子项目中执行构建。如果你在一个没有settings.gradle文件的目录下执行构建，\ngradle用下面的方法来寻找settings.gradle文件:\n 它在一个名为master的目录中查找，该目录具有与当前目录相同的嵌套级别。 如果还没有找到，它将搜索父目录。 如果还没有找到，构建将作为单个项目构建执行。 如果一个找到settings.gradle文件，gradle检查当前项目是否是在找到的settings.gradle文件中定义的多项目层次结构的一部分。\n如果不是，构建将作为单个项目构建执行。否则将执行多项目构建。  这种行为的目的是什么?Gradle需要确定您所在的项目是否是一个多项目构建的子项目。\n当然，如果它是一个子项目，那么只构建子项目及其相关的项目，但是Gradle需要为整个多项目构建创建构建配置。\n如果当前项目包含settings.gradle文件，构建总是被执行为：\n 如果settings.gradle文件没有定义一个多项目层次结构，则作为单个项目构建执行； 如果settings.gradle文件没有定义多项目层次结构，则作为多项目构建执行；  自动搜索settings.gradle文件只适用于具有物理层次结构或平面布局的多项目构建。\n对于平面布局，您还必须遵循上面描述的命名约定(master)。Gradle支持多项目构建的任意物理布局，但是对于这样的任意布局，\n您需要从设置文件所在的目录中执行构建。\nGradle为参与构建的每个项目创建一个项目对象。对于多项目构建，这些是在Settings对象(加上根项目)中指定的项目。\n默认情况下，每个项目对象都有一个与其顶层目录相同的名称，除了根项目之外，每个项目都有一个父项目。任何项目都可能有子项目。\n配置和执行单个项目构建 对于单个项目构建，初始化阶段之后的工作流非常简单。构建脚本针对在初始化阶段创建的项目对象执行。\n然后Gradle查找名称与作为命令行参数传递的名称相同的任务。如果这些任务名存在，它们将按照传递它们的\n顺序作为单独的构建执行。\n响应构建脚本中的生命周期 在构建过程中，您的构建脚本可以接收通知。这些通知通常采用两种形式:您可以实现特定的侦听器接口，也可以提供一个闭包，以便在触发通知时执行。\nProject evaluation 您可以在项目评估之前和之后立即收到通知。一旦应用了构建脚本中的所有定义，就可以使用它执行其他配置，或者用于一些自定义日志记录或概要分析。\n下面是一个向每个hasTests属性值为true的项目添加测试任务的示例：\nbuild.gradle\nallprojects {\rafterEvaluate { project -\u0026gt;\rif (project.hasTests) {\rprintln \u0026quot;Adding test task to $project\u0026quot;\rproject.task('test') {\rdoLast {\rprintln \u0026quot;Running tests for $project\u0026quot;\r}\r}\r}\r}\r}\rprojectA.gradle\nhasTests = true\r这个例子使用project.afterevaluate()方法来添加一个闭包，该闭包在项目评估之后执行。\n还可以在评估任何项目时接收通知。此示例执行一些项目评估的自定义日志记录。注意，无论项目评估成功与否，都会收到afterProject通知。\nbuild.gradle\ngradle.afterProject { project -\u0026gt;\rif (project.state.failure) {\rprintln \u0026quot;Evaluation of $project FAILED\u0026quot;\r} else {\rprintln \u0026quot;Evaluation of $project succeeded\u0026quot;\r}\r}\rTask creation 在将任务添加到项目后，可以立即收到通知。这可以用于在任务在构建文件中可用之前设置一些默认值或添加行为。\n下面的示例在创建每个任务时设置它的srcDir属性。\nbuild.gradle\ntasks.whenTaskAdded { task -\u0026gt;\rtask.ext.srcDir = 'src/main/java'\r}\rtask a\rprintln \u0026quot;source dir is $a.srcDir\u0026quot;\rTask execution graph ready 您可以在填充任务执行图之后立即收到通知.\n您还可以向TaskExecutionGraph添加TaskExecutionGraphListener来接收这些事件\nTask execution 您可以在执行任何任务之前和之后立即收到通知。\n下面的示例记录每个任务执行的开始和结束时间。注意，无论任务成功完成还是异常失败，都会收到afterTask通知。\nbuild.gradle\ntask ok\rtask broken(dependsOn: ok) {\rdoLast {\rthrow new RuntimeException('broken')\r}\r}\rgradle.taskGraph.beforeTask { Task task -\u0026gt;\rprintln \u0026quot;executing $task ...\u0026quot;\r}\rgradle.taskGraph.afterTask { Task task, TaskState state -\u0026gt;\rif (state.failure) {\rprintln \u0026quot;FAILED\u0026quot;\r}\relse {\rprintln \u0026quot;done\u0026quot;\r}\r}\r","description":"","id":6,"section":"post","tags":["Gradle","Gradle Lifecycle"],"title":"Gradle Build Lifecycle","uri":"http://chendm.gitee.io/blog/zh/post/gradle/build-lifecycle/"},{"content":"准备 我是按照PortableApps的规范来做便携软件的，所以需要用到的工具有：\n1、一个虚拟机：这是用来构建一个纯净的系统来安装程序的。可以用VMWare Workstation，或者免费的Virtual Box。虚拟机安装好后，装一个纯净的操作系统（注意：一定要干净哦！最好除了系统什么软件都没。什么VC++、.NET之类的补丁一个都没打过。），做一个快照，以后每次要做一个便携软件就恢复到这个纯净的快照先（或者用Deep Freeze把系统冻住o(∩_∩)o ，这样重启虚拟机就恢复了，比较省事。缺点是有可能对某些软件安装有影响，比方说需要重启的）。\n2、一个行为监控软件：用来监视软件安装后对系统做了哪些改动。可以用Total Uninstall，或者免费的RegShot，或者 VMWare ThinApp。下载好安装在虚拟机里（我个人觉得ThinApp最好，不怕安装过程中重启，而且会自己帮你把文件提出来）。\n3、PortableApps.com Launcher 和 NSIS Portable Unicode：最关键的两个工具。下载下来后，将它们安装到同一目录。例如：\nX:\\PortableApps\\PortableApps.comLauncher\rX:\\PortableApps\\NSISPortable\r4、PortableApps.com Development Toolkit：这个不是必须的，但是很有用，强烈建议下载（除非你是代码狂人）。\n5、PAL模板 （PortableApps.com Application Template）：熟练以后这个也不是必须的，但是初学的时候，用模版改改比较省事，而且不太会出错（其实熟练以后一样可以用模版改改的，省事省心啊！）。\n6、一个网址：http://portableapps.com/manuals/PortableApps.comLauncher/ ，这个是portablapps的用户手册，很多时候要到这里来查资料的。\n7、一个提取图标的软件。例如IconWorkshop之类的，这个选择太多了，自己找吧。\n制作 第一步，用前面准备好的行为监控软件给系统做第一个快照。这里不同的软件操作不一样，我就不一一讲了，不难的。\n第二步，安装准备制作成便携软件的软件。我就以IconWorkshop为例。全部都安装好以后运行一次，把文件类型关联取消掉，联机注册、自动更新之类的取消掉。当然也可以不运行，安装好结束。\n第三步，用监控软件做第二个快照，并对比两次快照。通过两次快照的对比，可以看到IconWorkshop在%ProgramDir%（也就是“Program Files”）底下创建了了一个名为“IconWorkshop”的文件夹，里面是它的程序文件。另外在%AppData%和%LocalAppData%这几个位置都写了文件。另外注册表方面，则是在“HKCU\\Software”下增加了“Axialis”这个项。这一步如果用VMWare Thinapp就很省事了，因为它会帮你把所有的改动都提取出来。\n关于两个变量%AppData%和%LocalAppData%，这两个都是PAL的系统变量，分别代表这些文件夹位置：\nLOCALAPPDATA：\nC:\\Documents and Settings\\Username\\Local Settings\\Application Data on XP and 2000,\rC:\\Users\\Username\\AppData\\Local on Vista and Win7.\rAPPDATA:\nC:\\Documents and Settings\\Username\\Application Data on XP and 2000,\rC:\\Users\\Username\\AppData\\Roaming on Vista and Win7.\r更多变量参见该网址：http://portableapps.chrismorgan.info/launcher/manual/ref/envsub/\n第四步，把之前准备好的PAL模版解压出来，并改名。将下载好的“PortableApps.com_Application_Template_X.X.zip”解压开，会得到一个名为“AppNamePortable”的文件夹，将它重命名，用你的软件的名称替换“AppName”，本例中将“AppNamePortable”改成“IconWorkshopPortable”。\n第五步，把程序文件复制到“App”文件夹下。我这里把“Program Files”下的整个“IconWorkshop”文件夹复制到“IconWorkshopPortable\\App”中。\n第六步，提取程序图标和注册表。这里就用IconWorkshop把它主程序的图标提取出来，保存到“IconWorkshopPortable\\App\\Appinfo\\Appicon.ico”,并将其导出成 16x16 的 png文件“Appicon_16.png”、32x32 的 “Appicon_32.png” 和 128x128（非必须） 的 “Appicon_128.png”。运行“Regedit”，把“HKCU\\Software\\Axialis”导出成“IconWorkshopPortable.reg”备用。\n第七步，提取Application Data。前面已经知道IconWorkshop会在%AppData%和%LocalAppData%这几个位置写文件，再仔细分析后发现，安装完成后，只有“%AppData%\\Axialis\\IconWorkshop\\Color Swatches\\”底下有一个“IconWorkshopSwatches”文件的，另外几个只建了个空的文件夹。\n在“IconWorkshopPortable\\App”下建一个文件夹“DefaultData”（DefaultData的作用：顾名思义，它是存放默认数据的地方，当便携软件第一次运行时，会先把它里面的内容拷到“AppNamePortable\\Data”中再运行），在里面建个目录，自己起个名字，我这里为了后面好分辨叫“Appdata”，并把整个“%AppData%\\Axialis\\IconWorkshop”底下的“Color Swatches\\IconWorkshopSwatches”目录下拷进去（不连前面的“Axialis\\IconWorkshop一起拷进去的原因见底下Launcher.ini部分”）。\n第八步，准备注册表文件。编辑之前准备好的“IconWorkshopPortable.reg”，把一些无用的信息删除掉，特别是注意下有没有关于程序路径设置的项，有的话要好好分析，没用的删，有用的另外记录下来再删，后面要写进脚本里的。然后把它复制到“DefaultData\\settings”底下。\n第九步，生成Appinfo.ini。这一步有两种方法：一种是直接在“Appinfo”下新建个“Appinfo.ini”，把代码写进去；另一种则是利用前面准备的“PortableApps.com Development Toolkit”，运行后打开自己做的软件目录，如“IconWorkshopPortable”，然后点击“Edit details”,一项项输进去，再保存就OK了。得到类似这样的一个“Appinfo.ini”：\n[Format]\rType=PortableApps.comFormat\rVersion=2.0\r[Details]\rName=IconWorkshop Portable\rAppID=IconWorkshopPortable\rPublisher=Shuewood Forest \u0026amp; PortableApps.com\rHomepage=PortableApps.com/IconWorkshopPortable\rCategory=Graphics \u0026amp; Pictures\rDescription=IconWorkshop is a tool for icon edit.\rLanguage=Multilingual\rTrademarks=Axialis IconWorkshop\r[License]\rShareable=false\rOpenSource=false\rFreeware=false\rCommercialUse=false\r[Version]\rPackageVersion=6.8.0.0\rDisplayVersion=6.8.0.0\r[Control]\rIcons=1\rStart=IconWorkshopPortable.exe\r第十步，写Launcher.ini。这是最难的一步，也是最关键的一步。它告诉PAL怎么把我们的软件便携化。细分为以下几步：\n1、创建“App\\Appinfo\\Launcher\\AppNamePortable.ini”。这里的文件名要和上面“Appinfo.ini”中的“AppID”相同。例如：“App\\Appinfo\\Launcher\\IconWorkshopPortable.ini”。\n2、写代码。这里有一个样例：\n[Launch]\r;主程序位置\rProgramExecutable=AppName\\AppName.exe\r;除了AppName.exe，当AppNameTray.exe正在运行时，便携软件也拒绝启动。\rCloseEXE=AppNameTray.exe ;当AppName.exe关闭后，等待AppNameTray.exe结束才真正结束便携软件。\rWaitForExe1=AppNameTray.exe\r;路径改变并不会影响便携软件运行，因此检测到路径改变时不提示警告。\rDirectoryMoveOK=yes\r[Activate]\r;表示本软件需要写注册表\rRegistry=true\r[DirectoriesMove]\r;当软件启动时，原%LOCALAPPDATA%\\AppName会被重命名（备份）为%LOCALAPPDATA%\\AppName-Backup-by-AppNamePortable，\r;当软件结束时，%LOCALAPPDATA%\\AppName会被删除，\r;%LOCALAPPDATA%\\AppName-Backup-by-AppNamePortable 被重命名（恢复）为%LOCALAPPDATA%\\AppName\r;（-=）的意思是程序结束时不将%LOCALAPPDATA%\\AppName备份到便携软件Data目录，因为这几个目录主要是日志、\r;临时文件，没有备份到便携设备的必要。如果需要备份到Data目录，则将“-”指定为其他名称。\r-=%LOCALAPPDATA%\\AppName -=%APPDATA%\\AppName\r-=%USERPROFILE%\\AppData\\LocalLow\\AppName\r[DirectoriesCleanupIfEmpty]\r;如为空目录，则在结束时删除目录，避免留下垃圾文件。下同\r1=%LOCALAPPDATA%\\AppNameAppName 2=%LOCALAPPDATA%\\AppName\r3=%APPDATA%\\AppName\r4=%USERPROFILE%\\AppData\\LocalLow\\AppName\r[RegistryKeys]\r;在程序启动时，HKCU\\Software\\AppName被重命名为\r;HKCU\\Software\\AppName-Backup-by-AppNamePortable，\r;Data\\settings\\AppNamePortable.reg 被导入注册表，在程\r;序结束后，反过来导出便携软件键值，恢复本机注册表项。\rAppNamePortable=HKCU\\Software\\AppName [RegistryValueWrite]\r;在程序启动时，在HKCU\\Software\\AppName\\AppName\\AppNamePath中写入便携软件Data目录路径，\r;以将数据库目录设定为便携软件的Data。更多PAL专有变量请参阅文档。\rHKCU\\Software\\AppName\\AppName\\AppNamePath=REG_SZ:%PAL:DataDir% [RegistryCleanupIfEmpty]\r;如为空项，则在结束时删除，避免留下注册表垃圾。\r1=HKCU\\Software\\AppName\r在本例中生成的“IconWorkshopPortable.ini”如下：\n[Launch]\rProgramExecutable=IconWorkshop\\IconWorkshop.exe\rDirectoryMoveOK=yes [Activate]\rRegistry=true [DirectoriesMove]\r;这个目录存的都是临时性的文件，不保存它，用完就删，所以等号前用“-”\r-=%LOCALAPPDATA%\\Axialis\\IconWorkshop\r;这里要调用DefaultData底下的Appdata，所以名字要一样，等号前用目录的名称\r;这里的基本原则就是：不准备保留也不影响使用的用“-”，需要从DefaultData或者保留修改的起个名字。\r;还有需要注意的是，当便携软件运行时，会自己生成“%APPDATA%\\Axialis\\IconWorkshop”目录，再把内容拷进去\r;所以在保存原有目录内容时，上面两个层级的目录别拷进去。\rAppdata=%APPDATA%\\Axialis\\IconWorkshop\r[DirectoriesCleanupIfEmpty]\r;这里是防止系统因为没装过Axialis的其它软件，在删除IconWorkshop目录后，留下Axialis目录\r1=%LOCALAPPDATA%\\Axialis\r2=%APPDATA%\\Axialis\r[RegistryKeys]\r;这里起了名字而没用用“-”是因为需要用这个名字来备份原注册表，用完还要还原的！\rIconWorkshopPortable=HKCU\\Software\\Axialis\\IconWorkshop\r[RegistryCleanupIfEmpty]\r;这里的目的和上面文件夹的目的是一样的\r1=HKCU\\Software\\Axialis\r具体各项的意义和其他参数见准备工作第六项的网址。\r经过上面的步骤，整个便携软件的准备工作就差不多了。但是如果碰上有的软件结束后有后台进程不会自己结束掉的情况，就需要一个额外的步骤了。\n额外步骤，写Custom Code。在“App\\Appinfo\\Launcher”下创建“Custom.nsh”,并写入内容。例如上面提到的需要关闭进程的，可以这么写：\n${SegmentFile}\r${SegmentPrePrimary}\rKillProcDLL::KillProc “AppNameBackground.exe”\r!macroend\r${SegmentPostPrimary}\rKillProcDLL::KillProc “AppNameBackground.exe”\r!macroend\r在程序启动与退出时结束AppNameBackground.exe进程（可能需要额外安装NSIS的KillPorcDLL插件）。\n更多可使用的Segments请参看：http://portableapps.chrismorgan.info/launcher/manual/advanced/segments/#segments\n最终步骤，编译与封包。准备工作都到位了以后，最终步骤就简单了。在 PortableApps.com Launcher 中载入 AppNamePortable 目录，\n按下一步编译。如果成功，会在 AppNamePortable 目录下生成 AppNamePortable.exe。\n需要注意的是，准备步骤的第三步一定要把两个软件放在一起，因为PortableApps.com Launcher需要调用NISI的。\n其实最后生成便携软件的就是NISI，前面的步骤都是让PortableApps.com Launcher准备NISI的脚本，\n所以牛人直接用NISI写PortableApp也是可以的。\n","description":"","id":7,"section":"post","tags":["PortableApps","PortableApps Get started"],"title":"PortableApps封装入门","uri":"http://chendm.gitee.io/blog/zh/post/portableapps/get-start/"},{"content":"把资源暴露为一个新的Kubernetes服务\n通过名称查找【deployment】, 【service】, 【replica set】, 【replication controller】或【pod】\n并使用此资源的selector作为在指定端口的新服务的 selector。\n【deployment】或【replica set】 仅当其selector可转换为服务支持的selector时，才会作为服务公开,\n例如，当 selector 仅包含 matchLabels 组件时。\n注意：如果不通过 \u0026ndash;port 指定端口，且被暴露的资源有多个端口，则这些端口会被所创建的新服务所重用。\n同样地，如果没有指定label，新服务会重用被暴露资源的所有label。\n","description":"","id":8,"section":"post","tags":["Kubernetes","Kubernetes kubectl"],"title":"kubectl expose命令","uri":"http://chendm.gitee.io/blog/zh/post/kubernetes/kubectl/expose/"},{"content":"下载kubectl \u0026amp; minikube kubectl.exe\nminikube-windows-amd64.exe\n安装virtualbox VirtualBox-6.1.4-136177-Win.exe\n设置环境变量 指定minikube集群的存储位置\nMINIKUBE_HOME = F:\\minikube\n创建并启动kubernetes集群 minikube start --image-mirror-country cn --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.9.0.iso --registry-mirror=https://3laho3y3.mirror.aliyuncs.com --registry-mirror=http://hub-mirror.c.163.com\r创建部署、服务，并暴露服务 kubectl create deployment nginx --image=nginx:latest\r此命令会创建一个deployment\r此deployment会部署一个ReplicaSet，此ReplicaSet会创建一个pod,使用指定的镜像创建一个容器\rk8s为此pod分配一个只能在集群内部访问的IP\rk8s持续监测此deployment的状态，当状态不满足时维护到满足为止\rkubectl expose deployment nginx --type=LoadBalancer --port=8080 --target-port=80\r此命令会为名称为nginx的dployment创建一个LoadBalancer类型的service, 并为其分配一个集群IP\r此service会把自身的8080端口映射到对应的deployment的pod的80端口\r同时集群会随机选择一个集群端口(例如：30060)映射到此service的8080端口\r此时通过：\u0026lt;集群IP\u0026gt;:\u0026lt;集群端口\u0026gt;就可以访问到nginx服务了\rnode \u0026lt;-\u0026gt; service \u0026lt;-\u0026gt; pod\r30060\u0026lt;-\u0026gt; 8080 \u0026lt;-\u0026gt; 80\rPod 是容器的集合，通常会将紧密相关的一组容器放到一个 Pod 中。\nPod 中的所有容器共享 IP 地址和 Port 空间，也就是说它们在一个 network namespace 中。\nPod 是 Kubernetes 调度的最小单位，同一 Pod 中的容器始终被一起调度。\n停止\u0026amp;启动集群 minikube stop\rminikube start --image-mirror-country cn\r","description":"","id":9,"section":"post","tags":["Kubernetes","Kubernetes Minikube"],"title":"Minikube安装\u0026基本使用","uri":"http://chendm.gitee.io/blog/zh/post/kubernetes/minikube/install/"},{"content":"前提条件 docker-machine创建宿主机：\ndm create -d \u0026quot;virtualbox\u0026quot; --engine-registry-mirror https://3laho3y3.mirror.aliyuncs.com --engine-registry-mirror http://f1361db2.m.daocloud.io --engine-registry-mirror https://reg-mirror.qiniu.com --engine-registry-mirror http://hub-mirror.c.163.com --engine-registry-mirror https://registry.docker-cn.com --engine-registry-mirror https://mirror.ccs.tencentyun.com --engine-registry-mirror https://dockerhub.azk8s.cn --virtualbox-cpu-count \u0026quot;4\u0026quot; --virtualbox-memory \u0026quot;8192\u0026quot; --virtualbox-disk-size \u0026quot;100000\u0026quot; --virtualbox-share-folder \u0026quot;F:\\vmshare\u0026quot; --virtualbox-boot2docker-url http://localhost/tool/boot2docker-19.iso vm\r创建容器\ndm ssh vm\rdocker run -it --name fuchsia-builder --cap-add NET_ADMIN -v /vmshare/share:/root/share ubuntu:latest /bin/bash\r安装依赖 apt-get update \u0026amp;\u0026amp; apt-get install -y vim wget build-essential curl git python unzip net-tools iproute2 uml-utilities ethstatus\r科学上网(v2ray-core) https://github.com/v2ray/v2ray-core/releases/download/v4.23.1/v2ray-linux-64.zip\nunzip v2ray-linux-64.zip\rcd v2ray\rwget https://trevorch.github.io/file/xxoo.json 新建restart.sh:\n#!/bin/bash\rPROCESS=`ps -ef|grep v2ray|grep -v grep|grep -v $0|awk '{ print $2}'`\rfor i in $PROCESS\rdo\recho \u0026quot;Kill the $1 process [ $i ]\u0026quot;\rkill -9 $i\rdone\rrm -rf nohup.out\rnohup ./v2ray --config $1 \u0026amp;\rtail -f nohup.out\r更改权限：chmod a+x restart.sh\n执行脚本：./restart.sh xxoo.json\n在~/.bashrc末添加：\nhttp_proxy=http://127.0.0.1:1081\rhttps_proxy=$http_proxy\rexport http_proxy https_proxy\r下载源码 cd /root\rcurl -s \u0026quot;https://fuchsia.googlesource.com/fuchsia/+/master/scripts/bootstrap?format=TEXT\u0026quot; | base64 --decode | bash\r下载完成后 在~/.bashrc最后添加：\nexport PATH=~/fuchsia/.jiri_root/bin:$PATH\rsource ~/fuchsia/scripts/fx-env.sh\r命令行执行：\nsource ~/.bashrc\r下载错误处理 脚本下载到一半时，出现如下报错：\nSome packages are skipped by cipd due to lack of access, you might want to run \u0026quot;cipd auth-login\u0026quot; and try again\rERROR: context deadline exceeded\r解决办法：打开下方网页登录google账户获得授权码\nhttps://accounts.google.com/o/oauth2/auth?access_type=offline\u0026amp;approval_prompt=force\u0026amp;client_id=446450136466-2hr92jrq8e6i4tnsa56b52vacp7t3936.apps.googleusercontent.com\u0026amp;redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob\u0026amp;response_type=code\u0026amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email\r执行命令：\ncipd auth-login\r命令行弹出：\nAuthorization code:\r贴上授权码即可。\n进入 fuchsia 源码目录，输入:\njiri update\r更新源代码，问题解决。\n编译 开启ccache\nsudo apt-get install -y ccache uuid-runtime\rbuild配置\u0026amp;build\nfx metrics enable\rfx set core.x64 --ccache\rfx build\r安装qemu 安装meson\napt-get install -y python3 python3-pip ninja-build\rpip3 install --user meson\r编辑 ~/.bashrc 添加如下内容：\nexport PATH=/root/.local/bin:$PATH\r执行：source ~/.bashrc\n安装glib\napt-get install -y zlib1g-dev libffi-dev gettext\rwget http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.64/glib-2.64.2.tar.xz\rtar -xvf glib-2.64.2.tar.xz\rcd glib-2.64.2\rmeson _build\rninja -C _build\rninja -C _build install\r编译qemu并安装\napt-get install -y libpixman-1-dev\rgit clone --recursive https://fuchsia.googlesource.com/third_party/qemu\rcd qemu\r./configure --target-list=aarch64-softmmu,x86_64-softmmu\rmake -j32\rsudo make install\r设置通信网络 mkdir /dev/net\rmknod /dev/net/tun c 10 200\rchmod a+w /dev/net/tun\rsudo ip tuntap add dev qemu mode tap user $USER\rsudo ifconfig qemu up\r启动qemu fx qemu -N\r","description":"","id":10,"section":"post","tags":["Fuchsia","Fuchsia Development"],"title":"开发：源码及编译","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/development/download-source/"},{"content":"简介 作为整个调度器开发工作的一部分，Zircon将迁移到一个新的公平调度器作为系统的主要调度器。\n本文讨论调度器的属性，以及如何在推出之前对其进行测试。\n启用公平调度器 默认情况下禁用公平调度程序。通过将GN构建参数enable_fair_scheduler设置为true，可以在编译时启用新的调度器。\n您可以像这样在GN调用中设置这个变量：\ngn gen build-zircon --args='enable_fair_scheduler=true'\r细化调度器追踪 新的调度器包括详细的跟踪工具，用于分析调度器的行为及其与系统中竞争的工作负载之间的交互和影响。\n通过将GN构建参数Detailed scheduler跟踪设置为true，可以在编译时启用详细跟踪:\ngn gen build-zircon --args='enable_fair_scheduler=true detailed_scheduler_tracing=true'\r调度器事件汇总 公平调度器概述 Zircon中的公平调度器 线程执行顺序 排序条件 每个线程的调度状态 可调试状态 定义 时间片 让步 ","description":"","id":11,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"调度：公平调度器","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/fair_scheduler/"},{"content":"背景 任何调度器的主要职责是在希望使用处理器时间的所有线程之间共享有限的处理器时间资源。\n在通用操作系统中，它试图以一种公平的方式做到这一点，以确保所有线程都可以取得一些进展。\n我们的调度器是LK调度器的升级版。因此，它从一个最小的调度器实现开始，并随着项目的增长而扩展以满足我们的需求。\n设计 概述 本质上，在机器的每个逻辑CPU上都有一个调度程序。这些调度器独立运行，并使用IPI(处理器间中断)进行协调。\n但是每个CPU负责调度运行在它上面的线程。有关如何确定线程在哪个CPU上以及如何/何时迁移的信息，请参见CPU分配部分。\n每个CPU都有自己的一组优先级队列。系统中的每个优先级一个对应一个队列，当前是32个优先级。\n请注意，这些是fifo队列，而不是称为优先级队列的数据结构。每个队列中都有一个等待执行的可运行线程的有序列表。\n当需要运行新线程时，调度器只需查看包含线程的编号最高的队列，将该队列的头取出并运行该线程。\n有关它如何决定哪个线程应该在哪个队列中的详细信息，请参阅下面的优先级管理。如果队列中没有要运行的线程，\n它将运行空闲线程，请参阅下面的实时和空闲线程以获得更多详细信息。\n每个线程在选择开始运行时都被分配相同的时间片大小(THREAD_INITIAL_TIME_SLICE)。\n如果它使用了它的整个时间片，它将被重新插入到适当的优先级队列的末尾。\n但是，如果其上次运行还剩余一些时间片，则会将其插入优先级队列的开头，以便能够尽快恢复。\n当它再次被捡起时，它将只运行前一个时间片的剩余时间。\n当调度器从优先级队列中选择一个新线程时，它将设置CPU的抢占计时器，可以是整个时间片，也可以是前一个时间片的剩余时间。\n当计时器触发时，调度器将停止该线程上的执行，将其添加到适当的队列中，选择另一个线程并重新开始。\n如果一个线程因等待一个共享资源而阻塞了，那么它就会从它的优先队列中取出，并被放置到一个共享资源的等待队列中。\n当它被解除阻塞时，它将被重新插入到一个合适的CPU优先队列(CPU分配)中，如果它还有剩余的时间片来运行，\n它将被添加到队列的前面进行加速处理。\n优先级管理 有三个不同的因素用于确定线程的有效优先级，有效优先级是用来确定它将在哪个队列中。\n第一个因素是基本优先级，它仅仅是线程请求的优先级。目前有32个级别，0是最低级别，31是最高级别。\n第二个因素是优先级的提高。这是一个被限制在 [-MAX_PRIORITY_ADJ, MAX_PRIORITY_ADJ]之间的值，\n用来抵消基本优先级，它被以下情况修改：\n 当线程被解除阻塞时，在等待共享资源或休眠之后，它会得到一个点的提升。 当一个线程让步(自愿放弃控制)，或者志愿者重新安排时间时，它的boost减少1，但下限为0(不会变为负数)。 当一个线程被抢占并使用完它的整个时间片时，它的boost减少1，但可以变为负值。  第三个因素是它继承的优先权。如果线程控制了一个共享资源，并且阻塞了另一个高优先级的线程，\n那么它将被临时提升到该线程的优先级，以允许它快速完成任务，并允许高优先级的线程继续工作。\n线程的有效优先级要么是继承的优先级(如果它有优先级)，要么是基本优先级加上它的boost。\n当这个优先级发生变化时，由于任何因素的变化，调度程序将把它移动到一个新的优先级队列并重新调度CPU。\n如果它现在是最高优先级的任务，则允许它拥有控制权;如果它不再是最高优先级的任务，则废弃它的控制权。\n这个系统的目的是确保交互线程得到快速的服务。这些线程通常与用户直接交互，并造成用户可感知的延迟。\n这些线程通常只做很少的工作，大部分时间被阻塞，等待另一个用户事件。因此，它们从解除阻塞中获得优先级提升，\n而执行大部分处理的后台线程在使用它们的整个时间片时获得优先级惩罚。\nCPU分配和迁移 线程可以使用CPU关联掩码请求希望在其上运行的CPU，它是一个32位掩码，其中0b001是CPU 1, 0b100是CPU 3, 0b101是CPU 1或CPU 3。\n这个掩码通常是被遵守的，但是如果它请求的CPU都是不活动的，它将被分配给另一个CPU。\n同样值得注意的是，如果它被固定到一个CPU上，那么它的掩码只包含一个CPU，并且该CPU变为非活动状态，\n那么线程将处于未服务状态，直到该CPU再次变为活动状态。有关详细信息，请参阅下面的CPU激活。\n当为线程选择CPU时，调度器将按顺序选择：\n CPU做选择，如果它是空闲的并且在关联掩码中。 最后运行线程的CPU，如果它是空闲的并且在关联掩码中。 关联掩码中的任何空闲CPU。 线程最后运行的CPU(如果它是活动的，并且在关联掩码中)。 CPU做选择，如果它是关联掩码中的唯一CPU，或者掩码中的所有CPU都不活动。 关联掩码中的任何活动CPU。  如果线程运行在一个不是在它的关联掩码中的CPU上(由于上面的情况5)，\n调度器将尝试在【每次线程被抢占】、【产生或自动重新调度时】纠正这个错误。\n而且，如果线程更改了它的关联掩码，调度器可能会迁移它。\n每当线程从共享资源或休眠中返回并需要分配优先级队列时，调度器将使用上述逻辑重新评估其对线程的CPU选择，并可能移动它。\nCPU激活 当一个CPU被停用，即关闭并从系统中移除时，调度器将把所有正在运行的线程转移到其他CPU上。\n唯一的例外是固定的线程，也就是说，它们的关联掩码中只有停用的CPU，这些线程被放回运行队列中，\n它们将处于未服务状态，直到重新激活CPU。\n当一个CPU被重新激活时，它将为等待的固定线程提供服务，并且由于上述规则，\n运行在非关联CPU上的线程应该通过它们的CPU调度器快速地迁移回来。\n对于新唤醒的CPU，没有活动的线程再平衡，但是由于它应该更频繁地空闲，应该会看到一些迁移，\n这是由上面CPU分配和迁移中列出的逻辑造成的。\n实时和空闲线程 这些特殊线程的处理方式略有不同。\n当没有其他线程可运行时，空闲线程运行。每个CPU上有一个，它位于优先级队列之外，\n但实际上是在优先级队列为-1的情况下。它用于跟踪空闲时间，可以被平台实现用于低功耗等待模式。\n实时线程(标记为THREAD_FLAG_REAL_TIME)允许在没有抢占的情况下运行，并将一直运行，直到它们阻塞、放弃或手动重新安排时间。\n","description":"","id":12,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"调度：Zircon调度","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/kernel_scheduling/"},{"content":"vDSO是访问Zircon系统调用的唯一方法。vDSO表示虚拟动态共享对象。动态共享对象是ELF(Executable Linkable Format)格式中用于共享库的术语。\n它是虚拟的，因为它不是从文件系统中的ELF文件加载的。相反，vDSO映像是由内核直接提供的。\nELF是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。\n是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。\nELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。\n使用vDSO 系统调用ABI vDSO是ELF格式的共享库。它的使用方式与ELF共享库的使用方式一样，根据ELF动态符号表中的符号名查找入口点 (the .dynsym section, located via DT_SYMTAB)。\nELF定义了一种散列表格式来优化符号表中的名称查找(the .hash section, located via DT_HASH)。\nGNU工具定义了一种改进的哈希表格式，使查找更加有效 (the .gnu_hash section, located via DT_GNU_HASH)。\nFuchsia ELF共享库(包括vDSO)仅使用DT GNU散列格式。(也可以通过线性搜索直接使用符号表，忽略哈希表。)\nvDSO使用了一个简化的布局，该布局没有可写段，也不需要动态重定位。这使得使用系统调用ABI更容易，\n而不需要实现通用的ELF加载器和完整的ELF动态链接语义。\nELF符号名与带有外部链接的C标识符相同。每个系统调用都对应于vDSO中的ELF符号，并且具有C函数的ABI。\nvDSO函数仅使用基本的特定于机器的C调用约定来控制机器寄存器和堆栈的使用，\n这在许多使用ELF的系统(如Linux和所有BSD变体)中是很常见的。\n它们不依赖于复杂的特性，比如ELF线程本地存储，也不依赖于fuchsia特定的ABI元素，比如SafeStack不安全的堆栈指针。\nvDSO 展开信息 vDSO有一个类型为PT_GNU_EH_FRAME的ELF程序头。这指向展开GNU .eh_frame格式的信息，它是标准的DWARF调用框架信息格式的近亲。\n该信息使得从vDSO代码中的调用帧中恢复寄存器值成为可能，这样就可以从vDSO代码中的PC值中的任何线程的寄存器状态中重构完整的堆栈跟踪。\n这些格式和它们在vDSO中的使用与在Fuchsia上的任何普通ELF共享库或使用公共GNU ELF扩展(如Linux和所有BSD变体)的其他系统中的使用是一样的。\nvDSO 构建ID vDSO有一个ELF构建ID，就像其他使用公共GNU扩展构建的ELF共享库和可执行文件一样。\n构建ID是一个标识了该二进制文件的特定构建的唯一字符串。它以ELF note格式存储，由类型为PT_NOTE的ELF程序头指向。\n名称为“GNU”、类型为NT_GNU_BUILD_ID的有效载荷是构成构建ID的字节序列。\n构建id的一个主要用途是将二进制文件与其调试信息和构建它们的源代码关联起来。\nvDSO二进制文件与内核二进制文件绑定(并嵌入其中)，并包含特定于每个内核构建的信息，因此，vDSO的构建ID也可以区分内核。\nzx_process_start()参数 [zx_process_start()]系统调用是程序加载器告诉内核启动新进程的第一个执行线程的方式。\n最后一个参数([zx process start()]文档中的arg2)是传递给寄存器中的新线程的一个普通uintptr_t值。\n按照惯例，程序加载器将vDSO映射到每个新进程的地址空间(在系统选择的随机位置)，\n并将映像的基本地址传递给arg2寄存器中新进程的第一个线程。\n这个地址是在内存中可以找到ELF文件头的地方，它指向所有其他必需的ELF格式元素来查找符号名，从而进行系统调用。\nPA_VMO_VDSO句柄 vDSO映像在编译时嵌入到内核中。内核将它作为只读VMO(Virtual Memory Object)暴露给用户空间。当程序加载器设置一个新进程时，\n使该进程能够进行系统调用的唯一方法是，在新进程的第一个线程开始运行之前将vDSO映射到新进程的地址空间。\n因此，每个将启动能够进行系统调用的其他进程的进程必须能够访问vDSO VMO。\n按照惯例，vDSO的VMO句柄在发送给每个新进程的zx_proc_args_t引导消息中从一个进程传递到另一个进程(see \u0026lt;zircon/processargs.h\u0026gt;)。\n句柄表中的VMO句柄条目由句柄信息条目PA_HND(PA_VMO_VDSO, 0)标识。\nvDSO实现细节 kazoo 工具 kazoo工具既生成构成公共系统调用API的C/C++函数声明，又生成在vDSO的实现中使用的一些C++和汇编代码。\n内核和vDSO代码之间的公共API和私有接口均由//zircon/vdso中的.fidl(Fuchsia Interface Definition Language)文件指定。\n系统调用可分为以下几组，它们的区别在于系统调用名称后面的属性:\n 既没有vdsocall也没有internal是简单的情况(它们是系统调用的主要部分)，其中公共API和私有API是完全相同的。\n它们完全由生成的代码实现。公共API函数的名称前缀是_zx_和zx_(别名)。 vdsocall项只是公共API的声明。这些功能由system/ulib/zircon/中的常规手写C++代码实现。\n这些源文件引用 #include “private.h”, 然后为系统调用定义c++函数，该函数的名称以_zx_为前缀。\n最后，他们使用VDSO_INTERFACE_FUNCTION宏在系统调用的名称前面加上zx(没有前导下划线)。\n此实现代码可以为任何其他系统调用项(公共生成的调用、公共手写的vdsocall或内部生成的调用)调用c++函数，但必须使用其私有入口点别名，该别名具有VDSO_zx_前缀。\n否则，代码是正常的(最小的)c++，但是必须是无状态的和可重入的(只使用它的堆栈和寄存器) internal条目是私有API的声明，仅供vDSO实现代码用于进入内核(例如通过其他函数实现vdsocall系统调用)使用。\n这些在vDSO实现中生成的函数具有与公共API中声明的相同的C签名(给定系统调用项的签名)。\n但是，它不使用_zx_和zx_前缀命名，只能通过#include “private.h”和VDSO_zx前缀来访问。  只读动态共享对象布局 vDSO是一个普通的ELF共享库，可以像对待其他库一样对待它。但是它被有意地保留为ELF共享库的一个小子集。这有几个好处:\n 将ELF映像映射到一个进程非常简单，并且不涉及任何复杂的、支持ELF PT_LOAD程序头文件的情况。\nvDSO的布局可以由特殊情况的代码来处理，不需要使用循环从ELF头中读取少量值。 使用vDSO不需要全功能的ELF动态链接。特别是，vDSO没有动态重定位。在ELF PT_LOAD段中的映射是惟一需要完成的设置。 vDSO代码是无状态的和可重入的。它只引用调用它的寄存器和堆栈。这使得它可以在各种上下文中使用，对用户代码如何组织自身的约束最小，这适合于操作系统的强制ABI。\n它还使代码更容易推理和审计，以确保健壮性和安全性。  布局是简单的两个连续的部分，每个部分包含对齐的整个页面：\n 第一个段是只读的，包括用于动态链接的ELF头文件和元数据，以及用于vDSO实现的私有常量数据。 第二段是可执行的，包含了vDSO代码。  整个vDSO映像只包含这两个段的页面，在ELF映像中呈现，就像它们应该出现在内存中一样。要在vDSO中进行映射，只需从vDSO的ELF头中收集两个值:每个段中的页面数。\n引导时只读数据 一些系统调用仅仅返回在整个系统运行期间都是常量的值，尽管系统的ABI是它们的值必须在运行时查询，并且不能编译成用户代码。\n这些值要么在编译时在内核中固定，要么在引导时由内核根据硬件或引导参数确定。\n例如：zx_system_get_version_string(), zx_system_get_num_cpus(), zx_ticks_per_second()\n因为这些值是常量，所以没必要进入内核读取它们。相反，vDSO实现这些是通过简单的c++函数返回从vDSO的只读数据段读取的常量。\n编译时固定的值(例如系统版本字符串)被简单地编译到vDSO中。\n对于在引导时确定的值，内核必须修改vDSO的内容。这是由启动时代码完成的，该代码在启动第一个用户空间进程并给它VMO句柄之前设置vDSO VMO。\n在编译时，将从嵌入到内核中的vDSO ELF文件中提取vDSO映像中vdso_constants数据结构的偏移量。\n在启动时，内核临时将包含vdso_constants的VMO页面映射到它自己的地址空间中，直到为当前运行的系统使用正确的值初始化结构。\n强制性 vDSO入口点是进入内核进行系统调用的唯一方法。用于进入内核的特定于机器的指令(例如x86上的syscall)不是系统ABI的一部分，用户代码直接执行这些指令是无效的。\n内核和vDSO代码之间的接口是一个私有实现细节。\n因为vDSO本身是在用户空间中执行的普通代码，所以内核必须健壮地处理从用户空间进入内核模式的所有可能的条目。\n但是，通过强制每个内核条目只能来自适当的vDSO代码，可以在一定程度上减少潜在的内核bug。\n这种强制执行还避免了用户空间代码的开发人员绕过ABI规则(由于无知、恶意或被误导的意图，他们试图绕过官方ABI的一些明确的限制)，\n这可能导致私有内核- vdso接口成为应用程序代码的实际ABI。\n内核以两种方式强制正确使用vDSO:\n 它限制了vDSO VMO映射到进程的方式。  当使用vDSO VMO调用zx_vmar_map()并请求ZX_VM_PERM_EXECUTE时，内核要求映射的偏移量和大小与vDSO的可执行段完全匹配。\n它也只允许一个这样的映射。一旦在流程中建立了有效的vDSO映射，就不能删除它。\n尝试第二次将vDSO映射到相同的进程中，从进程取消对vDSO代码的映射，或者使vDSO的可执行映射不使用正确的偏移量和大小，都将失败:ZX_ERR_ACCESS_DENIED。\n在编译时，从vDSO ELF文件中提取vDSO代码段的偏移量和大小，并在内核的映射实施代码中用作常量。\n当在一个进程中建立一个有效的vDSO映射时，内核将记录该进程的地址，以便能够快速地检查它。\n 它限制了什么PC(Program Counter)位置可以用来进入内核。  当用户线程进入内核进行系统调用时，寄存器指示调用的是哪个低级系统调用。\n底层系统调用是内核与vDSO之间的私有接口;许多直接对应于公共ABI中的系统调用，但其他则不是。\n对于每个低级系统调用，在vDSO代码中有一组固定的PC位置来调用该调用。\nvDSO的源代码定义了标识每个位置的内部符号。在编译时，这些位置从vDSO的符号表中提取出来，并用于生成内核代码，该代码为每个低级系统调用定义一个PC有效性谓词。\n由于系统中所有用户进程使用的vDSO代码只有一个定义，所以这些谓词只是检查从vDSO代码段开始的已知、有效、不变的偏移量。\n在进入内核进行系统调用时，内核检查x86上的syscall指令的PC位置(或其他机器上的等效指令)。\n它从PC上减去为进程在zx_vmar_map()时间记录的vDSO代码的基本地址，并将结果偏移量传递给正在调用的系统调用的有效性谓词。\n如果断言规则PC无效，则调用线程将不允许继续进行系统调用，而是采用与调用未定义的或特权机器指令所导致的机器异常类似的合成异常。\nVariants vDSO变体是一个还没有真正使用的实验性特性。有一个概念验证的实现和简单的测试，但是需要更多的工作来健壮地实现这个概念，并确定将提供哪些变体。\n其概念是提供仅导出完整vDSO系统调用接口的子集的vDSO映像的变体。例如，仅供设备驱动程序使用的系统调用可能与用于普通应用程序代码的vDSO变体不同。\n","description":"","id":13,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"系统调用：Vdso","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/vdso/"},{"content":"主要内容  简介 状态、状态变更及术语 观察信号 合成信号 用户信号  简介 信号可等待的内核对象向应用程序暴露的单个比特信息。\n每个内核对象可暴露一个或多个信号，大多数信号与对象类型相关的。\n例如，信号ZX_CHANNEL_READABLE指示“此通道端点有消息要读取”，而ZX_PROCESS_TERMINATED指示“此进程停止运行”。\n对象的信号存储在uint32位掩码中，其值（特定于对象）在zircon/types.h中定义。\ntypedef zx_signals_t 用于引用系统调用和其他api中的信号位掩码。\n大多数对象是可以等待的。端口是不可等待对象的一个例子。要确定一个对象是否是可等待的，可以调用zx_object_get_info()，\n主题参数传入ZX_INFO_HANDLE_BASIC，并测试ZX_OBJ_PROP_WAITABLE。\n状态、状态变更及术语 当一个信号的位是1时，它是活动的;当它的位是0时，它是不活动的。\n当一个信号被激活以响应一个事件时(即使它已经激活了)，我们称它为已断言的。\n当它在响应某个事件时变为非活动状态(即使它已经处于非活动状态)，则称为取消断言的\n例如:将消息写入通道端点时，另一端的ZX_CHANNEL_READABLE信号被断言(如果该信号不是活动的，则会导致该信号变为活动的)。\n当通道端点队列中的最后一条消息从该端点读取时，端点的ZX_CHANNEL_READABLE信号被取消断言(这会导致信号变成非活动)。\n观察信号 zx_object_wait_one(), zx_object_wait_many(), zx_object_wait_async()，与Port结合，可用于在一个或多个对象上等待特定的信号。\n如果多个线程正在操作同一个对象，这些系统调用的结果可能在调用线程实际操作它们时就已经过时了。\n例如，在通道上等待ZX_CHANNEL_READABLE的线程可能从zx_object_wait_one()中唤醒，结果发现没有待处理消息，\n因为另一个线程已经读取了它。\n合成信号 ZX_SIGNAL_HANDLE_CLOSED是一个合成信号，这只存在于zx_object_wait_one()或zx_object_wait_many()\n的结果中，并且表示正在等待的句柄已关闭，导致等待操作中止。\n当等待本身返回ZX_ERR_CANCELED时，该信号只能作为上述两个等待调用的结果获得。\n用户信号 有8个信号(ZX_USER_SIGNAL_0 到 ZX_USER_SIGNAL_7)在句柄具有适当的权限(分别是ZX_RIGHT_SIGNAL或ZX_RIGHT_SIGNAL_PEER)的时候，\n可使用zx_object_signal()和zx_object_signal_peer()将其置成被断言或取消断言。这些用户信号最初总是不活动的，并且只由对象信号系统调用来修改。\n","description":"","id":14,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"内核对象：Signals","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/signals/"},{"content":"权限与句柄相关联，并表达此句柄或句柄所引用的对象执行操作的权限。\n\u0026lt;zircon/rights.h\u0026gt;头部文件定义了各种类型对象的默认权限，可以通过zx_handle_replace()或zx_handle_duplicate()降权。\n   权限 授予的特权     ZX_RIGHT_DUPLICATE Allows handle duplication via zx_handle_duplicate()   ZX_RIGHT_TRANSFER Allows handle transfer via zx_channel_write()   ZX_RIGHT_READ Allows reading of data from containers (channels, sockets, VM objects, etc)    Allows mapping as readable if ZX_RIGHT_MAP is also present    TO BE REMOVED Allows inspection of object state   ZX_RIGHT_WRITE Allows writing of data to containers (channels, sockets, VM objects, etc)    Allows mapping as writeable if ZX_RIGHT_MAP is also present    TO BE REMOVED Allows modification of object state   ZX_RIGHT_EXECUTE Allows mapping as executable if ZX_RIGHT_MAP is also present   ZX_RIGHT_MAP Allows mapping of a VM object into an address space.   ZX_RIGHT_GET_PROPERTY Allows property inspection via zx_object_get_property()   ZX_RIGHT_SET_PROPERTY Allows property modification via zx_object_set_property()   ZX_RIGHT_ENUMERATE Allows enumerating child objects via zx_object_get_info() and zx_object_get_child()   ZX_RIGHT_DESTROY Allows termination of task objects via zx_task_kill()   ZX_RIGHT_SET_POLICY Allows policy modification via zx_job_set_policy()   ZX_RIGHT_GET_POLICY Allows policy inspection   ZX_RIGHT_SIGNAL Allows use of zx_object_signal()   ZX_RIGHT_SIGNAL_PEER Allows use of zx_object_signal_peer()   ZX_RIGHT_WAIT Allows use of zx_object_wait_one(), zx_object_wait_many(), and other waiting primitives   ZX_RIGHT_INSPECT Allows inspection via zx_object_get_info()   ZX_RIGHT_MANAGE_JOB NOT YET IMPLEMENTED Allows creation of processes, subjobs, etc.   ZX_RIGHT_MANAGE_PROCESS NOT YET IMPLEMENTED Allows creation of threads, etc   ZX_RIGHT_MANAGE_THREAD NOT YET IMPLEMENTED Allows suspending/resuming threads, etc    基本权限允许对句柄进行基本操作，默认情况下，大多数句柄类型都使用基本权限:\n ZX_RIGHT_DUPLICATE ZX_RIGHT_TRANSFER ZX_RIGHT_WAIT ZX_RIGHT_INSPECT  这四个权限一起使用时被称为ZX_RIGHTS_BASIC。\n","description":"","id":15,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"内核对象：权限","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/rights/"},{"content":"主要内容  基础 使用句柄 垃圾回收 特殊情况 无效句柄及句柄重用  基础 句柄是一种内核结构，它使得用户模式程序可以引用内核对象。句柄可以看作是到特定内核对象的会话或连接。\n通常情况下，多个进程通过不同的句柄并发地访问同一个内核对象。但是，单个句柄只能绑定到单个进程或绑定到内核。\n当句柄被绑定到内核时，我们说它是“在途的”。\n在用户模式下，句柄只是某个系统调用返回的特定数字。只有非在途的句柄对用户模式是可见的。\n表示句柄的整数只对该进程有意义。另一个进程中的相同数字可能不会映射到任何句柄，也可能映射到指向完全不同内核对象的句柄。\n句柄是任何32位的整数值, 例外的是 ZX_HANDLE_INVALID，它的值总是0。除此之外，一个有效句柄的整数值总是有两个最不重要的位。\n表示这些位的掩码可以使用ZX_HANDLE_FIXED_BITS_MASK来访问。\n对于内核模式，句柄是一个c++对象，它包含三个逻辑字段:\n 对内核对象的引用 对其绑定到的内核对象(或绑定到内核的进程)的权限 它绑定到的进程(或者它绑定到内核)  “权限”规定了允许对内核对象进行哪些操作。一个进程可能对同一个内核对象有两个具有不同的权限的句柄。\n图1: 用户进程开始创建句柄。\n图2: 用户进程使用系统调用创建内核对象(例如，一个事件)，并持有该对象的整数引用。\n图3: 句柄被创建后带有一组基本权限和适用于内核对象的任何附加权限。\n图4: 可以复制句柄。在此过程中可以删除权限。\n使用句柄 创建新内核对象并返回其句柄的系统调用有很多。举几个例子:\n zx_event_create() zx_process_create() zx_thread_create()  这些调用创建内核对象和指向它的第一个句柄。句柄被绑定到发起系统调用的进程，句柄的权限是内核对象的默认权限。\n只有zx_handle_duplicate()系统调用可以复制句柄，该句柄指向同一个内核对象，并绑定到发出系统调用的进程：\nzx_handle_replace()系统调用可以创建一个等价的句柄(可能具有较少的权限)，使原来的句柄无效。\nzx_handle_close()用于销毁句柄。\nzx_channel_write()接收一个绑定到调用进程的句柄，并将此句柄绑定到内核(将句柄置为在途中)\n以下两个系统调接收一个在途中的句柄并将其绑定到调用进程：\n zx_channel_read() zx_channel_call()  上面的channel和socket系统调用用于将句柄从一个进程转移到另一个进程。例如，可以用一个通道连接两个进程。\n要传输一个句柄，源进程调用zx_channel_write或zx_channel_call，然后目标进程调用同一通道上的zx_channel_read。\nzx_process_start()为一个新进程提供引导句柄，这个引导句柄可以用来请求其他句柄。\n引导句柄可以是任何可转移的内核对象，但最合理的情况是，它指向通道的一端，因此可以使用这个初始通道将更多的句柄发送到新进程。\n垃圾回收 如果句柄有效，则它所指向的内核对象保证有效。这是可以确保的，因为内核对象是有引用计数的，每个句柄都包含对其内核对象的引用。\n反之则不成立。当一个句柄被销毁时，并不意味着它指向的内核对象被销毁。可能有指向对象的其他句柄，或者内核本身可能持有对内核对象的引用。\n例如线程的句柄;线程的最后一个句柄关闭并不意味着线程已经终止。\n当内核对象的最后一个引用被释放时，要么内核对象被销毁，要么内核将该对象标记为垃圾收集对象;该对象将在稍后的某个时间(在它上面的一组挂起操作被完成时)被销毁。\n特殊情况  当一个句柄处于在途中时，如果它所写入的channel或socket被关闭时，此句柄也会关闭。 调试会话(和调试器)可能有特殊的系统调用来访问句柄。  无效句柄及句柄重用 将以下值传递给除了 zx_object_get_info 外的任何系统调用都是错误的：\n 已经关闭的句柄的值； ZX_HANDLE_INVALID的值，但zx_handle_close系统调用除外  内核在创建新对象时可以自由地重用那些已关闭句柄对应的整数值。因此，确保正确的处理卫生是很重要的：\n 不要让一个线程关闭给定的句柄，而让另一个线程以不雅的方式使用相同的句柄。即使第二个线程也在关闭它。 不要忽略ZX_ERR_BAD_HANDLE返回码。它们通常意味着代码有逻辑错误。  检测无效句柄的使用可以通过使用带有ZX_POL_ACTION_EXCEPTION的ZX_POL_BAD_HANDLE作业策略来实现自动化，\n从而在作业对象下的进程尝试上述任何无效情况时生成异常。\n","description":"","id":16,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"内核对象：句柄","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/handles/"},{"content":"Zircon是LK的一个分支，它的许多内部结构都是基于LK的，而上层则是新的。例如，Zircon有进程的概念，而LK没有。\n然而，Zircon进程是由LK级别的结构组成的，如LK的thread_t。\nLK是为嵌入式应用程序中通常使用的小型系统设计的内核。它是FreeRTOS或ThreadX等商业产品的一个很好的替代品。\n这样的系统通常只有非常有限的ram、一组固定的外围设备和一组有限的任务。\n另一方面，Zircon的目标是拥有高速处理器的现代手机和现代个人电脑，以及具有任意外设的非平凡内存(ram)来进行开放式计算。\n更具体地说，一些明显的区别是:\n LK可以在32位系统中运行。 Zircon仅支持64位。 Zircon具有一流的用户模式支持。 LK没有。 Zircon具有基于功能的安全模型。 在LK中，所有代码都是受信任的。  随着时间的推移，甚至低层次的构造也发生了变化，以适应新的需求并更好地适应系统的其余部分。\n","description":"","id":17,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"Zircon 与 LK","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/zx_and_lk/"},{"content":"主要内容  简介 系统调用 句柄及权限 内核对象ID 运行中的代码:Job,Process,Thread 消息传递:Socket及Channel 对象及信号 等待:等一个,等多个,端口 事件,事件对 共享内存:虚拟内存对象(VMO) 地址空间管理 Futexes 同步机制  简介 内核管理着许多不同类型的对象。可通过系统调用直接访问那些实现了Dispatcher接口的C++类，这些类在kernel/object中实现，其中多数是自包含的高级对象，有一些包装了低级的lk原语。\n系统调用 用户空间代码通过系统调用与内核对象交互，且几乎完全通过句柄实现。在用户空间中，句柄使用32位的整数表示(zx_handle_t类型)。\n当执行系统调用时，内核检查此句柄在当前调用进程的句柄表中引用的真实句柄。内核进一步检查真实句柄的类型正确性(向一个接收事件句柄的系统调用传递\n线程句柄会导致报错)，且此句柄有执行所请求操作的权限。\n从访问的角度看，系统调用分为三大类：\n 无限制的调用：数量较少，例如zx_clock_get()及zx_nanosleep()可被任何线程调用; 使用句柄作第一参数的调用，参数就是被操作对象：数量占了大部分，例如zx_channel_write()及zx_port_queue(); 创建对象且无句柄参数的调用：例如zx_event_create()及zx_channel_create()，对它们的访问和限制由调用进程所在的Job控制。  系统调用由libzircon.so提供，它是Zircon内核向用户空间提供的一个虚拟共享库，广为人知的叫法是虚拟动态共享对象(vDSO)。它们\n是C ELF ABI函数，命名形式：zx_noun_verb()或zx_noun_verb_direct-object()。\n系统调用以FIDL的形式定义在//zircon/vdso中。这些定义先被fidlc处理，然后由kazoo从fidlc获取IR表示并输出各种格式，\n这些输出在VDSO、内核等等中被作为胶水使用。\n句柄及权限 对象可被多个句柄(在一个或多个进程中)引用;\n对大部分对象来说，当最后一个引用此对象的句柄被关闭时，这个对象要么被销毁，要么被置为不可撤销的最终状态。\n句柄可通过写入通道(使用zx_channel_wirte(),或在一个新进程的第一个线程中使用zx_process_start()传递一个句柄)\n的方式从一个进程移动到另一个进程。\n在句柄或它所引用的对象上的可执行的操作是由与此句柄关联的权限控制的。引用同一个对象的两个句柄可以有不一样的权限。\n当在代码中把句柄传递进来时，可用zx_handle_duplicate()及zx_handle_replace()这两个系统调用来获取引用同一对象的额外句柄，\n且可选择减权。zx_handle_close()系统调用用于关闭句柄，并在其是所引用对象的最后一个引用的情况下释放其所引用的对象。\nzx_handle_close_many()系统调用用于关闭一组句柄。\n内核对象ID 内核中的每个对象都有一个内核对象ID(简称koid)，它是一个64位无符号整数，可用于标识对象，且在运行时系统的整个生命周期中唯一。\n这意味着koid是不会被重用的。\n有两种特别的koid值：\n ZX_KOID_INVALID: 值为0且被用作“null”哨兵; ZX_KOID_KERNEL: 只有一个内核，且内核有自己的koid.  内核生成的koid只使用63位，这为人为设置koid留出了余地。内核生成koid的分配顺序是未被指定的，且这是一个未来会变化的部分。\n人为koid的存在是为了支持诸如标识人为对象、追踪虚拟线程，这些由工具类使用的东西。人为koid的分配由每个程序来定，本文档不作任何规定或惯例约束。\n运行中的代码:Job,Process,Thread 线程表示在一个地址空间中的执行(CPU寄存器、栈等等)，地址空间进程，线程属于进程，进程属于Job，Job定义了各种资源限制，Job又属于父Job，所有Job\n都可以溯根至Root Job。Root Job由内核在启动时创建，并传递给第一个开始执行的用户空间进程：userboot。\n如果没有Job句柄，则进程中的线程不可能创建另外一个进程或另外一个Job。\n程序加载功能是由内核层之上的用户空间基础设施和协议提供的。\n参考：zx_process_create(), zx_process_start(), zx_thread_create(), zx_thread_start()\n消息传递:Socket及Channel Socket和Channel都是IPC对象，它们是可以两端双向使用的。创建Socket或Channel对象时会返回两个句柄，分别指向这个对象的两个端点。\nSocket是面向流的，且数据可以以一个或多个字节为单元写入或读出。短写(假设Socket的缓冲已满)及短读(假设请求的数据比缓冲中的要多)都是可以的。\nChannel是面向数据报的，且有最大消息大小(由ZX_CHANNEL_MAX_MSG_BYTES控制)，且消息被句柄引用有最大数量限制\n(由ZX_CHANNEL_MAX_MSG_HANDLES控制)。不支持短写及短读。\n当句柄被写入Channel时，此句柄会从写进程中移除。当接收进程读取带有句柄的消息时，此句柄会被添加到此进程中。在写和读两个事件之间，句柄是\n持续存在的(确保句柄所引用的对象一直都在)，除非被写入通道的另一端已经关闭(此时，消息会被另一端丢弃且消息中包含的句柄会被关闭，进而导致所引用的\n对象被销毁)。\n参考：zx_channel_create(), zx_channel_read(), zx_channel_write(), zx_channel_call(), zx_socket_create(), zx_socket_read(), zx_socket_write()\n对象及信号 对象最多可有32个信号(使用zx_signalst类型表示，且由ZXSIGNAL定义), 这些信号表示关于它们的一段信息。例如Channel和Socket可以是READABLE或\nWRITABLE，进程或线程可以是TERMINATED的，等等。\n线程可以在一个或多个对象上等待信号以变成激活状态。\n等待:等一个,等多个,端口 线程可在单个句柄上使用zx_object_wait_one()来等待信号以被激活，或在多个句柄上使用zx_object_wait_many()来等待信号以被激活。\n两种方式都支持在超时后返回(即使没有任何待处理信号)。\n由于时间松弛的存在，超时可能会偏离指定的最终时间。具体参考时间松弛相关内容。\n如果线程需要等待大量的句柄，使用Port是更为有效的方式。其它对象可绑定到Port对象上，当这些对象上有信号时，这个Port对象会接收到\n包含待处理信号的数据包。\n参考：zx_port_create(), zx_port_queue(), zx_port_wait(), zx_port_cancel().\n事件,事件对 事件是最简单的对象，除了它的活动信号集合没有其他状态。\n事件对是一对可以相互发出信号的事件。事件对的一个有用属性是，\n当一个事件对的一端离开时(对它的所有句柄都已关闭)，对等端关闭信号在另一端被断言。\n参考：zx_event_create(), zx_eventpair_create()\n共享内存:虚拟内存对象(VMO) 虚拟内存对象表示一组内存物理页，或潜在的页面(将按需懒惰地创建/填充)。\n可以使用zx_vmar_map()将它们映射到进程的地址空间中，以及使用zx_vmar_unmap解除映射。\n映射页面的权限可以使用zx_vmar_protect()进行调整。\n也可以使用zx vmo read()和zx vmo write()直接读写VMO。因此，像“创建一个VMO，向其中写入数据集，\n并将其交给另一个进程使用”这样的一次性操作可以避免将它们映射到地址空间的成本。\n地址空间管理 虚拟内存地址区域(VMAR)提供了管理进程地址空间的抽象。在创建进程时，指向Root VMAR的句柄被交给进程创建者。\n该句柄引用了一个跨越整个地址空间的VMAR。这个空间可以通过zx_vmar映射()和zx_vmar_allocate()接口来划分。\nzx_vmar_allocation()可用于生成新的VMAR(称为子区域)，这些VMARs可用于将地址空间的各个部分分组在一起。\n参考：zx_vmar_map(), zx_vmar_allocate(), zx_vmar_protect(), zx_vmar_unmap(), zx_vmar_destroy(),\nFutexes 同步机制 Futexes是与用户空间原子操作一起使用的内核原语，用于实现高效的同步原语。例如，在争用情况下只需要进行一次系统调用的互斥锁。\n通常标准库的实现者对它们感兴趣。Zircon的libc和libc++为【互斥对象】、【条件变量】等提供了C11、c++和pthread的接口，并使用Futexes实现。\n参考：zx_futex_wait(), zx_futex_wake(), zx_futex_requeue().\n","description":"","id":18,"section":"post","tags":["Fuchsia","Fuchsia Kernel"],"title":"Zircon 内核概念","uri":"http://chendm.gitee.io/blog/zh/post/fuchsia/kernel/concepts/"},{"content":"下载Archlinux ISO镜像 archlinux-2020.03.01-x86_64.iso\n安装VirtualBox VirtualBox-6.1.4-136177-Win.exe\n创建VirtualBox虚拟机，并挂载Archlinux镜像，启动虚拟机 分区 分区方案：\rsda1----200M----/boot\rsda2----1G------swap\rsda3----剩余空间------/\r#fdisk /dev/sda\r创建sda1分区：\r输入n\r回车\r输入开始扇区,默认回车\r输入结束扇区，要创建200M的分区,应该输入：+200M；\r创建sda2分区：\r输入n\r回车\r输入开始扇区,默认回车\r输入结束扇区，要创建1G的分区,应该输入：+1G；\r创建sda3分区：\r输入n\r回车\r输入开始扇区,默认回车\r输入结束扇区，使用剩余全部空间，回车；\r格式化分区并挂载 # mkfs.ext4 /dev/sda1\r# mkfs.ext4 /dev/sda3\r# mkswap /dev/sda2\r# swapon /dev/sda2\r# # mount /dev/sda3 /mnt\r# mkdir /mnt/boot\r# mount /dev/sda1 /mnt/boot\r修改镜像源 # nano /etc/pacman.d/mirrorlist\r在最顶处添加：\rServer = https://mirrors.163.com/archlinux/$repo/os/$arch\r安装基本系统 # pacstrap /mnt base base-devel\r# pacman -Syu # 更新\r配置系统 安装grub引导程序\r# pacstrap /mnt grub-bios\r生成系统挂载表\r# genfstab -p /mnt \u0026gt;\u0026gt; /mnt/etc/fstab\r切到新安装的系统\r# arch-chroot /mnt /bin/bash\r安装nano编辑器\r# pacman -S nano\r设置系统语言\r# nano /etc/locale.gen -- 去掉以下两行前的注释：\ren_US.UTF-8 UTF-8\rzh_CN.UTF-8 UTF-8\r# locale-gen -- 生成区域语言文件\recho LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf\rexport LANG=en_US.UTF-8\r设置时区\r# ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\r# hwclock --systohc --utc -- 调整硬件时钟\r更改主机名\r# echo trevor \u0026gt; /etc/hostname\r安装ssh服务\r# pacman -Sy openssh\r# systemctl enable sshd.serice\r更改root密码\r# passwd root\r添加新用户\r# useradd -m -g users -G wheel -s /bin/bash trevor\r# passwd trevor\r# nano /etc/sudoers # 添加超级权限 在root ALL=(ALL) ALL后添加一行：\rtrevor ALL=(ALL) ALL\r#配置引导\r# grub-install /dev/sda\r# grub-mkconfig -o /boot/grub/grub.cfg\r#创建一个初始 RAM disk\rmkinitcpio -p linux\r至此，就可以了！\n","description":"","id":19,"section":"post","tags":["Linux","Linux Archlinux"],"title":"Archlinux 安装及配置","uri":"http://chendm.gitee.io/blog/zh/post/linux/archlinux/install/"},{"content":"基础概念 利率 也称“利息率”，指一定时期内利息额与本金额的比率。利率有年利率、月利率和日利率三种表现形式：\n年利率：按本金百分比表示，在中国称为“分”；\n月利率：按本金千分比表示，在中国称为“厘”；\n日利率：按本金万分比表示，在中国称为“毫”。\n计算公式：利率=利息额/本金额\n浮动利率 基准利率是人民银行公布的商业银行存款、贷款、贴现等业务的指导性利率。各金融机构的利率允许：\n存款利率可以在基准利率基础上下浮10%；\n贷款利率可以在基准利率基础上下浮20%。\n货币供给与需求 现金 也称“通货”，它：\n是政府授权发行的不兑现的银行券和辅币；\n是一国的法偿货币；\n是央行提供基础货币的主要形式。\n货币层次 根据货币流动性原则，以存款及其信用工具转换为现金所需时间和成本作为标准，对货币划分的层次。\n央行为了便于进行宏观经济运行监测和货币政策操作，按照不同的统计口径确定不同的货币供应量。\n中国的具体层次如下：\nM0=现金；\nM1=现金 + 活期存款(一般不包括官方机构和外国银行在商业银行的存款)；\nM2=M1 + 准货币 + 可转让存单。准货币指除了活期存款以外的一切公私存款；\nM3=M2 + CD + 长于隔夜的限期回购协议和欧洲美元；\nM4=M3 + 定期存款 + 私人部门持有的建房互助协会的股份，这是英国英格兰银行公布的一个货币口径；\nL=M3 + 非银行公众持有的储蓄券 + 短期国库券 + 商业票据 + 银行承兑票据。\n狭义货币 流通中的现金与商业银行活期存款的总和，即狭义货币供应量，它是央行制定及执行货币政策的主要观测依据。\n现金是法定通货的存在形式；\n商业银行活期存款，存款人随时可签发支票进行转让或流通，具有支付手段和流通手段两种职能，存款通货。\n侠义货币用M1表示： M1=M0(流通中的货币)+企业活期存款+机关团体部队存款+农村存款。\n广义货币 狭义货币(M1)和商业银行定期存款的总和。\n由于各种定期存款一向可以提前支取转化为现实购买力，把它算作货币，可以更全面地反映货币流通状况，便于分析和控制市场金融活动。\n以此类推，储蓄存款、可转让定期存单、易转手的短期债券等作为具有通货性质的准货币，也可按其流动性状况囊括进来，通常用M2、M3作代号进行分类统计，依次递增的准货币在流动性上依次递减。\n基础货币 也称“货币基数”、“货币基础”、“强力货币”或“高能货币”，经过商业银行的存货款业务而能扩张或收缩货币供应量的货币。\n西方国家的基础货币包括商业银行存入央行的存款准备金(包括法定准备金和超额准备金)与社会公众所持有的现金之和。\n央行通过调节基础货币的数量就能数倍扩张或收缩货币供应量，因此：\n基础货币构成市场货币供应量的基础，因其是一种活动力强大的货币，具有高能量，故亦称之为“强力货币”或“高能货币”。\n货币乘数 央行提供的基础货币与货币供应量扩张关系的数量表现。即央行扩大或缩小一定数量的基础货币之后，能使货币供应总量扩大或缩小的比值。亦称基础货币的扩张倍数。\n基本计算公式：Ms=Bm\n超额准备金 商业银行或存款机构在货币当局规定必须缴纳的法定准备金之外，保留的一部分准备金。\n商业银行保留超额准备金主要是解决意外的大额提现、结清存款或避免错过更好的投资机会。\n超额准备金的变动将影响到货币的乘数大小，在基础货币供应量不变的情况下，它制约着银行体系创造货币的能力。\n货币流通速度 同一单位的货币在一定时期内充当流通的次数。\n它是决定商品流通过程中所需要货币量的重要因素之一，并且能在一定程度上弥补流通中货币数量的不足。\n现实中对货币流通速度测定，主要根据不同层次货币与相应商品的流通，确定各层次货币的流通速度，如：\n以商品零售额与现金余额的比值，测定这时期现金的流通速度；\n以国民生产总值与M1或M2的比值，测定M1或M2的流通速度。\n","description":"","id":20,"section":"post","tags":["Economics","Economics Monetary"],"title":"M0 M1 M2 M3","uri":"http://chendm.gitee.io/blog/zh/post/monetary-economics/m0-m1-m2-m3/"},{"content":"Go程序可编译成不同平台的可执行文件 set GOARCH=amd64\rset GOOS=linux\rgo build xx.go\r这样生成的文件没有任何依赖，直接运行就可以了！\n","description":"","id":21,"section":"post","tags":["Go","Go env"],"title":"Go 程序编译成不同平台的执行文件","uri":"http://chendm.gitee.io/blog/zh/post/go/env/compile/"},{"content":"安装VirtualBox VirtualBox-6.1.4-136177-Win.exe\n下载 Docker Machine docker-machine-Windows-x86_64.exe\n放置至 D:\\Docker\\Machine\\0.16.2 并重命名为 dm.exe\n配置环境变量  把 D:\\Docker\\Machine\\0.16.2 添加到path环境变量； 删除path环境变量中带OpenSSH的项，否则会导致Docker Machine卡在 Waiting for an IP\u0026hellip;; 新建环境变量 MACHINE_STORAGE_PATH 指定docker机器存储位置。  boot2docker.iso 镜像配置 下载最新版nginx: nginx-1.17.9.zip\n解压nginx至某一目录，并启动nginx\n下载最新版boot2docker.iso: boot2docker\n放置于nginx的html目录中\n使用Docker Machine部署一台机器  打开cmd命令行界面，输入命令：  dm create -d \u0026quot;virtualbox\u0026quot; --engine-registry-mirror http://hub-mirror.c.163.com --engine-registry-mirror https://reg-mirror.qiniu.com --engine-registry-mirror https://registry.docker-cn.com --virtualbox-memory \u0026quot;2048\u0026quot; --virtualbox-boot2docker-url http://localhost/tools/boot2docker-19.iso vm\r执行过程如下：  C:\\Users\\Trevorch\u0026gt;dm create -d \u0026quot;virtualbox\u0026quot; --engine-registry-mirror https://3laho3y3.mirror.aliyuncs.com --engine-registry-mirror http://f1361db2.m.daocloud.io --engine-registry-mirror https://reg-mirror.qiniu.com --engine-registry-mirror http://hub-mirror.c.163.com --engine-registry-mirror https://registry.docker-cn.com --engine-registry-mirror https://mirror.ccs.tencentyun.com --engine-registry-mirror https://dockerhub.azk8s.cn --virtualbox-memory \u0026quot;2048\u0026quot; --virtualbox-boot2docker-url http://localhost/tool/boot2docker.iso vm1\rRunning pre-create checks...\rCreating machine...\r(vm1) Downloading F:\\vms\\cache\\boot2docker.iso from http://localhost/tool/boot2docker.iso...\r(vm1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%\r(vm1) Creating VirtualBox VM...\r(vm1) Creating SSH key...\r(vm1) Starting the VM...\r(vm1) Check network to re-create if needed...\r(vm1) Windows might ask for the permission to configure a dhcp server. Sometimes, such confirmation window is minimized in the taskbar.\r(vm1) Waiting for an IP...\rWaiting for machine to be running, this may take a few minutes...\rDetecting operating system of created instance...\rWaiting for SSH to be available...\rDetecting the provisioner...\rProvisioning with boot2docker...\rCopying certs to the local machine directory...\rCopying certs to the remote machine...\rSetting Docker configuration on the remote daemon...\rChecking connection to Docker...\rDocker is up and running!\rTo see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: dm env vm1\r登录docker机器并查看环境信息：  C:\\Users\\Trevorch\u0026gt;dm ssh vm1\r( '\u0026gt;')\r/) TC (\\ Core is distributed with ABSOLUTELY NO WARRANTY.\r(/-_--_-\\) www.tinycorelinux.net\rdocker@vm1:~$ docker info\rClient:\rDebug Mode: false\rServer:\rContainers: 1\rRunning: 1\rPaused: 0\rStopped: 0\rImages: 1\rServer Version: 19.03.5\rStorage Driver: overlay2\rBacking Filesystem: extfs\rSupports d_type: true\rNative Overlay Diff: true\rLogging Driver: json-file\rCgroup Driver: cgroupfs\rPlugins:\rVolume: local\rNetwork: bridge host ipvlan macvlan null overlay\rLog: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\rSwarm: inactive\rRuntimes: runc\rDefault Runtime: runc\rInit Binary: docker-init\rcontainerd version: b34a5c8af56e510852c35414db4c1f4fa6172339\rrunc version: 3e425f80a8c931f88e6d94a8c831b9d5aa481657\rinit version: fec3683\rSecurity Options:\rseccomp\rProfile: default\rKernel Version: 4.14.154-boot2docker\rOperating System: Boot2Docker 19.03.5 (TCL 10.1)\rOSType: linux\rArchitecture: x86_64\rCPUs: 1\rTotal Memory: 1.951GiB\rName: vm1\rID: 7SHL:Y3WY:Z4WI:B7ZY:LSTV:CT6J:ZFZU:MH2A:MFSP:4GE4:GB4I:R6JE\rDocker Root Dir: /mnt/sda1/var/lib/docker\rDebug Mode: false\rRegistry: https://index.docker.io/v1/\rLabels:\rprovider=virtualbox\rExperimental: false\rInsecure Registries:\r127.0.0.0/8\rRegistry Mirrors:\rhttps://3laho3y3.mirror.aliyuncs.com/\rhttp://f1361db2.m.daocloud.io/\rhttps://reg-mirror.qiniu.com/\rhttp://hub-mirror.c.163.com/\rhttps://registry.docker-cn.com/\rhttps://mirror.ccs.tencentyun.com/\rhttps://dockerhub.azk8s.cn/\rLive Restore Enabled: false\rProduct License: Community Engine\rdocker@vm1:~$\r查看docker-machine连接远程docker引擎的命令行环境设置  C:\\Users\\Trevor\u0026gt;dm env vm1\rSET DOCKER_TLS_VERIFY=1\rSET DOCKER_HOST=tcp://192.168.99.100:2376\rSET DOCKER_CERT_PATH=E:\\vms\\machines\\vm\rSET DOCKER_MACHINE_NAME=vm\rSET COMPOSE_CONVERT_WINDOWS_PATHS=true\rREM Run this command to configure your shell:\rREM @FOR /f \u0026quot;tokens=*\u0026quot; %i IN ('dm env vm') DO @\r只要按照以上方式设置环境，就可以使用docker客户端、docker-machine、docker-compose连接到远程docker引擎。\n至此，就可以使用docker环境了！\n","description":"","id":22,"section":"post","tags":["Docker","Docker Machine"],"title":"Docker Machine 安装及配置","uri":"http://chendm.gitee.io/blog/zh/post/docker/machine/install/"},{"content":"主要内容  Markdown是什么？ 谁创造了它？ 为什么要使用它？ 怎么使用？ 谁在用？ 尝试一下  正文 1. Markdown是什么？ Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。 Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。\n2. 谁创造了它？ 它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。\n他有着足以让你跪拜的人生经历：\n 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。  天才都有早逝的归途。\n3. 为什么要使用它？  它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。  4. 怎么使用？ 如果不算扩展，Markdown的语法绝对简单到让你爱不释手。\nMarkdown语法主要分为如下几大部分：\n标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \\，符号'`\u0026rsquo;。\n4.1 标题 两种形式：\n1）使用=和-标记一级和二级标题。\n 一级标题\n=========\n二级标题 ---------\n 效果：\n 一级标题 二级标题  2）使用#，可表示1-6级标题。\n # 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n 效果：\n 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题  4.2 段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n4.3 区块引用 在段落的每行或者只在第一行使用符号\u0026gt;,还可使用多个嵌套引用，如：\n \u0026gt; 区块引用\n\u0026gt;\u0026gt; 嵌套引用\n 效果：\n 区块引用\n 嵌套引用\n  4.4 代码区块 代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如 普通段落：\nvoid main() { printf(\u0026ldquo;Hello, Markdown.\u0026quot;); }\n代码区块：\nvoid main()\r{\rprintf(\u0026quot;Hello, Markdown.\u0026quot;);\r}\r 注意:需要和普通段落之间存在空行。\n4.5 强调 在强调内容两侧分别加上*或者_，如：\n *斜体*，_斜体_ **粗体**，__粗体__\n 效果：\n 斜体，斜体 粗体，粗体\n 4.6 列表 使用·、+、或-标记无序列表，如：\n -（+*） 第一项\n-（+*） 第二项\n- （+*）第三项\n 注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果：\n  第一项 第二项 第三项   有序列表的标记方式是将上述的符号换成数字,并辅以.，如：\n 1 . 第一项\n2 . 第二项 3 . 第三项\n 效果：\n  第一项 第二项 第三项   4.7 分割线 分割线最常使用就是三个或以上*，还可以使用-和_。\n4.8 链接 链接可以由两种形式生成：行内式和参考式。 行内式：\n [younghz的Markdown库](https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo;)。\n 效果：\n younghz的Markdown库。\n 参考式：\n [younghz的Markdown库1][1] [younghz的Markdown库2][2] [1]:https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo; [2]:https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo;\n 效果：\n younghz的Markdown库1 younghz的Markdown库2\n 注意：上述的[1]:https:://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;不出现在区块中。\n4.9 图片 添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n4.10 反斜杠\\ 相当于反转义作用。使符号成为普通符号。\n4.11 符号'`\u0026rsquo; 起到标记作用。如：\n `ctrl+a`\n 效果：\n ctrl+a\n 5. 谁在用？ Markdown的使用者：\n GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等  6. 尝试一下  Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。  当然，最终境界永远都是笔下是语法，心中格式化 :)。\n注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。\n虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]\n(http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。\n以上基本是所有traditonal markdown的语法。\n其它： 列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。\n   代码库 链接     MarkDown https://github.com/younghz/Markdown   MarkDownCopy https://github.com/younghz/Markdown    关于其它扩展语法可参见具体工具的使用说明。\n","description":"","id":23,"section":"post","tags":["Manual","Manual Markdown"],"title":"Markdown 手册","uri":"http://chendm.gitee.io/blog/zh/post/markdown/manual/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":24,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://chendm.gitee.io/blog/zh/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":25,"section":"gallery","tags":null,"title":"Photo","uri":"http://chendm.gitee.io/blog/zh/gallery/photo/"}]